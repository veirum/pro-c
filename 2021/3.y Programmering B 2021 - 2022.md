# 3.y Programmering B 2021 - 2022

![](https://www.computersciencedegreehub.com/wp-content/uploads/2021/03/Brief-History-of-Programming-Languages.jpg)

Her kan i finde en oversigt over indholdet i modulerne samt de brugte materialer.  Jeg vil sÃ¥ vidt muligt prÃ¸ve at skrive hvad vi skal igennem til gangen fÃ¸r. Ikke som lektie men sÃ¥ I kan orientere jer i det kommende stof. 





## Mandag 9/8 - 2021

*1 modul*

Velkommen tilbage fra sommerferien â˜€ï¸ðŸ˜ŽðŸ–ðŸ§‰. I dag gennemgÃ¥r vi lÃ¦replanen og kigger lidt i krystalkuglen frem mod eksamensprojektet. Vi skal ogsÃ¥ snakke lidt om planerne for Ã¥ret og om det fÃ¸rste forlÃ¸b.



###  Samarbejde

NÃ¥r i skal i gang med eksamensprojektet skal i arbejde sammen i grupper. Derfor skal vi i gang med at Ã¸ve os pÃ¥ at samarbejde nÃ¥r vi programmere. Vi skal igennem forskellige emner sÃ¥som:



- Dokumentation og kommentare i kode
- Flowchart (gjordt rigtigt!)
- UML Klassediagrammer
- Git og Github



ðŸ“š**Materialer**

[LÃ¦replan Programmering B](https://www.uvm.dk/-/media/filer/uvm/gym-laereplaner-2017/valgfag/programmering-b-valgfag-august-2017.pdf)



## Onsdag 11/8 2021

*2 moduler*

### Flowchart

![Flowchart example](https://www.visual-paradigm.com/servlet/editor-content/tutorials/flowchart-tutorial/sites/7/2018/09/flowchart-example.png)

Flowcharts er et vigtigt vÃ¦rktÃ¸j nÃ¥r ideer og tanker skal ud af hovedet. Det er en mÃ¥de at visualisere forlÃ¸bet af logikken i ens program. Alt kan selvfÃ¸lgelig ikke lÃ¸ses med et flowchart, men det er et godt redskab til at skabe overblik over forlÃ¸bet i ens kode samt begynde at fÃ¥ dem konkretiseret. 

I en samarbejdssituation er det vigtigt at fÃ¥ ideerne ud af hovedet da vi som mennesker ikke kan lÃ¦se andre tanker og let kan misforstÃ¥ komplekse mundtlige forklaringer. Med en model kan man derimod mere eksplicit diskutere en ide. SÃ¥ jo hurtigere I fÃ¥r ideerne beskrevet med modeller jo bedre.



âœï¸ **Opgave**

- Lav et flowchart individuelt, hvor I  beskriver jeres morgenrutine. 
- GÃ¥ sammen 2 og 2 for at gennemgÃ¥ jeres flowchart. Check om de gÃ¥r op logisk og om de rette symboler er brugt.
- Ret dem til og lav dem prÃ¦senterbare ved hjÃ¦lp af et digitalt program, klar til at prÃ¦senter for for klassen.



### UML Klasse-diagram

For at beskrive sit program i mere detalje kan man benytte sig af UML (unified modeling language) klasse diagrammer. Klassediagrammer er et godt vÃ¦rktÃ¸j nÃ¥r man skal aftale hvilke variabler(attributter), funktioner(metoder) og hvad returnerer klassen. Her er det muligt at aftale ned i detaljen hvordan programmet snakker sammen.

| ![Klassediagram](https://www.researchgate.net/profile/Robert-France-2/publication/220868351/figure/fig1/AS:671528823820294@1537116356318/A-UML-Class-Diagram-for-a-video-poker-game.png) |
| :----------------------------------------------------------: |
| *Et eksempel pÃ¥ et klassediagram. For betydning af bokse og pile lÃ¦s materialet neden for.* |



### Eksempelkode

```javascript
class Field {
    constructor(x, y, numberOfTiles) {
        this.tint = 100;
        this.x = x;
        this.y = y;
        this.tiles = numberOfTiles;
        this.piece = 2;
    }

    update() {
        //are the mouse hovering above?
        if (mouseX > this.x && mouseX < this.x + width / this.tiles && mouseY > this.y && mouseY < this.y + height / this.tiles) {
            this.tint = 200;
            if (this.piece === 2) {
                if (clicked == true) {
                    this.piece = int(board.player);
                    board.player = !board.player;
                }

            }

        } else {
            this.tint = 50;
        }
    }

    show() {
        fill(this.tint);
        strokeWeight(2);
        rect(this.x, this.y, width / this.tiles, height / this.tiles);

        if (this.piece === 0) {
            noFill();
            strokeWeight(20);
            ellipse(this.x + width / this.tiles / 2, this.y + height / this.tiles / 2, width / this.tiles * 0.9);
        }

        if (this.piece === 1) {
            noFill();
            strokeWeight(20);
            line(this.x + width / this.tiles * 0.1, this.y + height / this.tiles * 0.1, this.x + (width / this.tiles) * 0.9, this.y + (height / this.tiles) * 0.9);
            line(this.x + (width / this.tiles) * 0.9, this.y + height / this.tiles * 0.1, this.x + height / this.tiles * 0.1, this.y + (height / this.tiles) * 0.9);
        }
    }
}
```



```javascript
class Board {
  constructor(numberOfTiles) {
    this.player = false;
    this.fields = [];
    this.tiles = numberOfTiles;
    for (let j = 0; j < this.tiles; j++) {
      for (let i = 0; i < this.tiles; i++) {
        this.fields.push(new Field(width / this.tiles * i, width / this.tiles * j, this.tiles));
      }
    }
    //print(this.fields.length);
  }

  check() {
    //check for a stalemate
    if (this.fields[0].piece != 2 && this.fields[1].piece != 2 && this.fields[2].piece != 2 && this.fields[3].piece != 2 && this.fields[4].piece != 2 && this.fields[5].piece != 2 && this.fields[6].piece != 2 && this.fields[7].piece != 2 && this.fields[8].piece != 2) {
      gameState = 2;
      winner = -1;
    }

    //check for a the winner horizontally O
    for (let i = 0; i < 9; i += 3) {
      if (this.fields[i].piece === 0 && this.fields[i + 1].piece === 0 && this.fields[i + 2].piece === 0) {
        winner = 0;
        gameState = 2;
      }
    }

    //check for a the winner horizontally X
    for (let i = 0; i < 9; i += 3) {
      if (this.fields[i].piece === 1 && this.fields[i + 1].piece === 1 && this.fields[i + 2].piece === 1) {
        winner = 1;
        gameState = 2;
      }
    }

    for (let i = 0; i < 3; i++) {
      if (this.fields[i].piece === 0 && this.fields[3 + i].piece === 0 && this.fields[6 + i].piece === 0) {
        winner = 0;
        gameState = 2;
      }
    }

    for (let i = 0; i < 3; i++) {
      if (this.fields[i].piece === 1 && this.fields[3 + i].piece === 1 && this.fields[6 + i].piece === 1) {
        winner = 1;
        gameState = 2;
      }
    }

    //check for a the winner diagonally
    if (this.fields[0].piece === 0 && this.fields[4].piece === 0 && this.fields[8].piece === 0) {
      winner = 0;
      gameState = 2;
    }
    if (this.fields[2].piece === 0 && this.fields[4].piece === 0 && this.fields[6].piece === 0) {
      winner = 0;
      gameState = 2;
    }
    if (this.fields[0].piece === 1 && this.fields[4].piece === 1 && this.fields[8].piece === 1) {
      winner = 1;
      gameState = 2;
    }
    if (this.fields[2].piece === 1 && this.fields[4].piece === 1 && this.fields[6].piece === 1) {
      winner = 1;
      gameState = 2;
    }
  }

  update() {
    for (let i = 0; i < this.fields.length; i++) {
      this.fields[i].update();
    }
  }

  show() {
    for (let i = 0; i < this.fields.length; i++) {
      this.fields[i].show();
    }
  }
}
```



âœï¸ **Opgave**

- LÃ¦s og forstÃ¥ Teksten om UML klasse-diagrammer ved at fÃ¸lge linket nedenunder.
- Gennese programmet og identificer antallet af klasser. Linket til programmet findes nedenunder.
- Lav klassediagrammer til de identificerede klasser fra eksempelkoden.
- LÃ¦s artiklen "How to comment like a Pro", link neden under.



ðŸ“š**Materialer:**

[Oversigt over Flowchart-symboler](https://www.smartdraw.com/flowchart/flowchart-symbols.htm)

[How to Comment your code like a Pro](https://www.elegantthemes.com/blog/wordpress/how-to-comment-your-code-like-a-pro-best-practices-and-good-habits)

[UML Klassediagram](https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/)





## 19/8 2021 Flowcharts og Klassediagrammer

*1 modul*

I dag skal vi se pÃ¥ de producerede flowcharts over jeres morgenrutiner samt de to klasser.

Herefter prÃ¸ver vi nogle eksempler sa<mmen pÃ¥ tavlen.
